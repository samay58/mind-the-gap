<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>__PROJECT_NAME__ â€” Codebase Map</title>
<style>
/* ============================================================================
   LONDON TUBE DESIGN SYSTEM
   ============================================================================ */

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --bg: #F4F1EC;
  --bg-alt: #EDE8E0;
  --fg: #1C1C1C;
  --fg-muted: #6B6B6B;
  --fg-dim: #A0A0A0;
  --panel-bg: #FAFAF7;
  --panel-border: #D4D0C8;
  --grid-color: rgba(0,0,0,0.04);
  --search-bg: #FFFFFF;
  --search-border: #C8C4BC;
  --badge-bg: #E8E4DC;
  --badge-fg: #555;
  --tooltip-bg: #1C1C1C;
  --tooltip-fg: #F4F1EC;
  --station-fill: #FAFAF7;
  --station-stroke: #1C1C1C;
  --highlight-glow: rgba(255,200,0,0.3);

  --line-width: 8px;
  --station-r: 11;
  --interchange-r: 15;
  --font-body: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

  --transition-fast: 0.15s ease;
  --transition-med: 0.3s ease;
}

[data-theme="dark"] {
  --bg: #0E1621;
  --bg-alt: #162030;
  --fg: #E8E4DC;
  --fg-muted: #8899AA;
  --fg-dim: #556677;
  --panel-bg: #162030;
  --panel-border: #2A3A4E;
  --grid-color: rgba(255,255,255,0.03);
  --search-bg: #1A2636;
  --search-border: #2A3A4E;
  --badge-bg: #1A2636;
  --badge-fg: #8899AA;
  --tooltip-bg: #E8E4DC;
  --tooltip-fg: #0E1621;
  --station-fill: #162030;
  --station-stroke: #E8E4DC;
  --highlight-glow: rgba(255,200,0,0.15);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  height: 100%;
  overflow: hidden;
  background: var(--bg);
  color: var(--fg);
  font-family: var(--font-body);
  font-size: 13px;
  -webkit-font-smoothing: antialiased;
}

/* ============================================================================
   LAYOUT
   ============================================================================ */

.frame {
  height: 100%;
  display: flex;
  flex-direction: column;
}

header {
  padding: 14px 24px;
  display: flex;
  align-items: center;
  gap: 16px;
  border-bottom: 1px solid var(--panel-border);
  flex-shrink: 0;
  background: var(--bg);
  z-index: 20;
}

.header-roundel {
  width: 36px;
  height: 36px;
  flex-shrink: 0;
}

.header-text {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1px;
}

.title {
  font-weight: 700;
  font-size: 16px;
  letter-spacing: 0.5px;
  line-height: 1.2;
}

.subtitle {
  color: var(--fg-muted);
  font-size: 11px;
  font-weight: 500;
  letter-spacing: 0.3px;
}

/* Search bar */
.search-wrap {
  position: relative;
  width: 220px;
  flex-shrink: 0;
}

.search-wrap svg {
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 14px;
  height: 14px;
  color: var(--fg-dim);
  pointer-events: none;
}

#searchInput {
  width: 100%;
  padding: 7px 10px 7px 30px;
  border: 1px solid var(--search-border);
  border-radius: 6px;
  background: var(--search-bg);
  color: var(--fg);
  font-family: var(--font-body);
  font-size: 12px;
  outline: none;
  transition: border-color var(--transition-fast);
}

#searchInput:focus {
  border-color: #003688;
}

#searchInput::placeholder {
  color: var(--fg-dim);
}

/* Header controls */
.header-controls {
  display: flex;
  gap: 4px;
  flex-shrink: 0;
}

.icon-btn {
  width: 32px;
  height: 32px;
  border: 1px solid var(--panel-border);
  border-radius: 6px;
  background: var(--search-bg);
  color: var(--fg);
  font-family: var(--font-body);
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition-fast);
  line-height: 1;
}

.icon-btn:hover {
  background: var(--fg);
  color: var(--bg);
  border-color: var(--fg);
}

.icon-btn.active {
  background: var(--fg);
  color: var(--bg);
}

/* ============================================================================
   LEGEND
   ============================================================================ */

.legend {
  position: fixed;
  bottom: 14px;
  left: 24px;
  display: flex;
  gap: 16px;
  font-size: 11px;
  font-weight: 500;
  z-index: 15;
  background: var(--bg);
  padding: 8px 14px;
  border-radius: 8px;
  border: 1px solid var(--panel-border);
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 7px;
  cursor: pointer;
  user-select: none;
  transition: opacity var(--transition-fast);
}

.legend-item.dimmed {
  opacity: 0.35;
}

.legend-swatch {
  width: 24px;
  height: 6px;
  border-radius: 3px;
  display: inline-block;
}

/* ============================================================================
   ZOOM CONTROLS
   ============================================================================ */

.controls {
  position: fixed;
  bottom: 14px;
  right: 24px;
  display: flex;
  gap: 2px;
  z-index: 15;
}

.controls button {
  width: 32px;
  height: 32px;
  border: 1px solid var(--panel-border);
  background: var(--search-bg);
  color: var(--fg);
  font-family: var(--font-body);
  font-size: 16px;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.controls button:first-child { border-radius: 6px 0 0 6px; }
.controls button:last-child { border-radius: 0 6px 6px 0; }
.controls button:not(:first-child):not(:last-child) { border-radius: 0; }
.controls button:hover { background: var(--fg); color: var(--bg); }

/* Station count */
.station-count {
  position: fixed;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  color: var(--fg-dim);
  z-index: 15;
  letter-spacing: 0.5px;
}

/* ============================================================================
   MAP
   ============================================================================ */

.map-wrap {
  flex: 1;
  overflow: hidden;
  position: relative;
  cursor: grab;
}

.map-wrap:active { cursor: grabbing; }

#map {
  width: 100%;
  height: 100%;
}

/* Dot grid background */
.dot-grid {
  fill: var(--grid-color);
}

/* Lines */
.map-line {
  fill: none;
  stroke-width: var(--line-width);
  stroke-linecap: round;
  stroke-linejoin: round;
  transition: opacity var(--transition-med), stroke-width var(--transition-med);
}

.map-line.dimmed { opacity: 0.12; }
.map-line.highlighted { stroke-width: 12px; opacity: 1; }

/* Stations */
.station { cursor: pointer; outline: none; }
.station:focus { outline: none; }

/* Regular station: roundel (colored circle with white center ring) */
.station-outer {
  transition: r var(--transition-fast), opacity var(--transition-med), transform var(--transition-fast);
}

.station-inner {
  fill: var(--station-fill);
  transition: r var(--transition-fast), opacity var(--transition-med);
  pointer-events: none;
}

.station:hover .station-outer,
.station:focus .station-outer {
  filter: url(#glow);
}

.station.dimmed .station-outer,
.station.dimmed .station-inner {
  opacity: 0.15;
}

.station.dimmed .station-label,
.station.dimmed .station-sublabel {
  opacity: 0.1;
}

.station.highlighted .station-outer {
  filter: url(#glow);
}

/* Interchange: double-circle roundel */

/* Terminal: capsule */
.terminal-rect {
  rx: 14;
  ry: 14;
  transition: opacity var(--transition-med);
}

.terminal-inner-rect {
  rx: 10;
  ry: 10;
  fill: var(--station-fill);
  transition: opacity var(--transition-med);
  pointer-events: none;
}

/* Labels */
.station-label {
  font-size: 11px;
  font-weight: 600;
  fill: var(--fg);
  pointer-events: none;
  transition: opacity var(--transition-med);
  letter-spacing: 0.2px;
}

.station-sublabel {
  font-size: 9px;
  fill: var(--fg-muted);
  pointer-events: none;
  font-weight: 500;
  transition: opacity var(--transition-med);
}

/* Pulse animation for path tracing */
@keyframes pulse-dot {
  0% { offset-distance: 0%; opacity: 1; }
  80% { opacity: 1; }
  100% { offset-distance: 100%; opacity: 0; }
}

.pulse-dot {
  r: 5;
  fill: white;
  filter: url(#pulse-glow);
  offset-rotate: 0deg;
  animation: pulse-dot 2.5s ease-in-out infinite;
}

/* ============================================================================
   TOOLTIP
   ============================================================================ */

.tooltip {
  position: fixed;
  pointer-events: none;
  background: var(--tooltip-bg);
  color: var(--tooltip-fg);
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 11px;
  line-height: 1.4;
  max-width: 260px;
  z-index: 50;
  opacity: 0;
  transition: opacity var(--transition-fast);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.tooltip.show { opacity: 1; }

.tooltip-name {
  font-weight: 600;
  margin-bottom: 2px;
}

.tooltip-role {
  opacity: 0.8;
}

/* ============================================================================
   DETAIL PANEL
   ============================================================================ */

.overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  opacity: 0;
  visibility: hidden;
  transition: opacity var(--transition-med);
  z-index: 100;
  backdrop-filter: blur(2px);
}

.overlay.on { opacity: 1; visibility: visible; }

.panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.96);
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 12px;
  width: 440px;
  max-width: 92vw;
  max-height: 80vh;
  overflow-y: auto;
  padding: 24px;
  opacity: 0;
  visibility: hidden;
  z-index: 101;
  transition: opacity var(--transition-med), transform var(--transition-med), visibility var(--transition-med);
  box-shadow: 0 20px 60px rgba(0,0,0,0.15);
}

.panel.on {
  opacity: 1;
  visibility: visible;
  transform: translate(-50%, -50%) scale(1);
}

.panel-head {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 6px;
}

.panel-roundel {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.panel-roundel-inner {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--panel-bg);
}

.panel-name {
  font-weight: 700;
  font-size: 16px;
  line-height: 1.2;
}

.panel-badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.3px;
  text-transform: uppercase;
  background: var(--badge-bg);
  color: var(--badge-fg);
  margin-left: 8px;
}

.panel-path {
  color: var(--fg-muted);
  font-size: 11px;
  font-family: 'SF Mono', 'Consolas', 'Liberation Mono', monospace;
  margin-bottom: 16px;
  padding-left: 44px;
}

.panel-divider {
  border: none;
  border-top: 1px solid var(--panel-border);
  margin: 0 0 14px 0;
}

.panel-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--fg-muted);
  margin-bottom: 6px;
}

.panel-role {
  font-size: 13px;
  line-height: 1.6;
  margin-bottom: 14px;
}

.panel-details {
  font-size: 12px;
  line-height: 1.6;
  color: var(--fg-muted);
  margin-bottom: 16px;
}

.panel-conn {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.panel-conn-row {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
}

.panel-conn-arrow {
  font-weight: 700;
  font-size: 14px;
  width: 20px;
  text-align: center;
  flex-shrink: 0;
}

.panel-conn-arrow.downstream { color: #007D32; }
.panel-conn-arrow.upstream { color: #003688; }

.panel-conn-name {
  color: var(--fg);
  font-weight: 500;
}

.panel-close {
  position: absolute;
  top: 16px;
  right: 16px;
  width: 28px;
  height: 28px;
  border: none;
  border-radius: 6px;
  background: transparent;
  color: var(--fg-muted);
  font-size: 18px;
  cursor: pointer;
  font-family: var(--font-body);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition-fast);
}

.panel-close:hover {
  background: var(--badge-bg);
  color: var(--fg);
}

/* ============================================================================
   SVG EXPORT OVERLAY
   ============================================================================ */

.export-toast {
  position: fixed;
  top: 20px;
  right: 20px;
  background: var(--tooltip-bg);
  color: var(--tooltip-fg);
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 500;
  z-index: 200;
  opacity: 0;
  transform: translateY(-10px);
  transition: all var(--transition-med);
  pointer-events: none;
}

.export-toast.show {
  opacity: 1;
  transform: translateY(0);
}
</style>
</head>
<body>

<script>
// ============================================================================
// SUBWAY MAP CONFIG - Generated by /subway skill
// ============================================================================

/* __SUBWAY_CONFIG_START__ */
const CONFIG = {
  project: {
    name: "Project Name",
    subtitle: "Project Description"
  },

  lines: {
    // Lines are defined here with colors and labels
    // Example:
    // api: { color: "#003688", label: "API" },
    // core: { color: "#007D32", label: "Core" },
  },

  stations: {
    // Stations are defined here
    // Example:
    // main: {
    //   name: "main.py",
    //   path: "src/main.py",
    //   line: "core",
    //   x: 100, y: 120,
    //   role: "Entry point for the application",
    //   details: "Initializes the app, parses CLI args, and starts the main loop.",
    //   type: "terminal",  // "regular" | "interchange" | "terminal"
    //   feeds: ["config", "server"],
    //   fed_by: [],
    //   badge: "entry point"  // optional
    // },
  },

  paths: [
    // Path definitions connecting stations
    // Example:
    // { line: "core", stations: ["main", "config", "server"] },
    // { line: "api", stations: ["server", "routes", "handlers"], type: "branch" },
  ]
};
/* __SUBWAY_CONFIG_END__ */

// ============================================================================
// RENDERER - Do not modify below this line
// ============================================================================

document.addEventListener('DOMContentLoaded', () => {
  const { project, lines, stations, paths } = CONFIG;

  // --- State ---
  let selectedStation = null;
  let hiddenLines = new Set();
  let searchQuery = '';
  let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

  // --- Utility: generate octilinear path between two stations ---
  function octiPath(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;

    // Straight horizontal
    if (Math.abs(dy) < 5) return `M ${x1},${y1} L ${x2},${y2}`;
    // Straight vertical
    if (Math.abs(dx) < 5) return `M ${x1},${y1} L ${x2},${y2}`;

    // Octilinear: go horizontal, then 45-degree diagonal, then finish
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    const diag = Math.min(absDx, absDy);

    if (absDx >= absDy) {
      // Mostly horizontal: go horizontal, then diagonal
      const horizLen = absDx - diag;
      const midX = x1 + Math.sign(dx) * horizLen;
      return `M ${x1},${y1} L ${midX},${y1} L ${x2},${y2}`;
    } else {
      // Mostly vertical: go vertical, then diagonal
      const vertLen = absDy - diag;
      const midY = y1 + Math.sign(dy) * vertLen;
      return `M ${x1},${y1} L ${x1},${midY} L ${x2},${y2}`;
    }
  }

  // --- Utility: generate path d attribute for a series of stations ---
  function generatePathD(stationIds) {
    if (stationIds.length < 2) return '';
    const points = stationIds
      .filter(id => stations[id])
      .map(id => ({ x: stations[id].x, y: stations[id].y }));
    if (points.length < 2) return '';

    let d = `M ${points[0].x},${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
      const prev = points[i - 1];
      const cur = points[i];
      const segment = octiPath(prev.x, prev.y, cur.x, cur.y);
      // Remove the M command from subsequent segments
      d += ' ' + segment.replace(/^M\s*[\d.]+,[\d.]+\s*/, '');
    }
    return d;
  }

  // --- Utility: find connected stations (upstream/downstream) ---
  function findConnected(stationId) {
    const upstream = new Set();
    const downstream = new Set();

    function traceUp(id) {
      const s = stations[id];
      if (!s) return;
      (s.fed_by || []).forEach(depId => {
        if (!upstream.has(depId)) {
          upstream.add(depId);
          traceUp(depId);
        }
      });
    }

    function traceDown(id) {
      const s = stations[id];
      if (!s) return;
      (s.feeds || []).forEach(depId => {
        if (!downstream.has(depId)) {
          downstream.add(depId);
          traceDown(depId);
        }
      });
    }

    traceUp(stationId);
    traceDown(stationId);

    return { upstream, downstream };
  }

  // --- Utility: find which lines connect to a station ---
  function stationLines(stationId) {
    const result = new Set();
    paths.forEach(p => {
      if (p.stations.includes(stationId)) result.add(p.line);
    });
    return result;
  }

  // --- Utility: check if a path connects to any of given stations ---
  function pathConnectsTo(pathDef, stationSet) {
    return pathDef.stations.some(id => stationSet.has(id));
  }

  // --- Label placement engine ---
  function computeLabelPos(id, s) {
    // Default: above station
    let anchor = 'middle';
    let lx = s.x;
    let ly = s.y - (s.type === 'interchange' ? 24 : 20);
    let placement = 'above';

    // Check for collisions with other stations and adjust
    const others = Object.entries(stations).filter(([oid]) => oid !== id);
    const tooCloseAbove = others.some(([, o]) =>
      Math.abs(o.x - s.x) < 80 && o.y < s.y && o.y > s.y - 60
    );
    const tooCloseBelow = others.some(([, o]) =>
      Math.abs(o.x - s.x) < 80 && o.y > s.y && o.y < s.y + 60
    );
    const tooCloseLeft = others.some(([, o]) =>
      Math.abs(o.y - s.y) < 30 && o.x < s.x && o.x > s.x - 120
    );
    const tooCloseRight = others.some(([, o]) =>
      Math.abs(o.y - s.y) < 30 && o.x > s.x && o.x < s.x + 120
    );

    // Interchange stations: prefer right side
    if (s.type === 'interchange') {
      if (!tooCloseRight) {
        anchor = 'start';
        lx = s.x + 22;
        ly = s.y + 4;
        placement = 'right';
      } else if (!tooCloseLeft) {
        anchor = 'end';
        lx = s.x - 22;
        ly = s.y + 4;
        placement = 'left';
      }
    } else if (tooCloseAbove && !tooCloseBelow) {
      ly = s.y + (s.type === 'terminal' ? 36 : 28);
      placement = 'below';
    }

    return { lx, ly, anchor, placement };
  }

  // --- Apply theme ---
  function applyTheme() {
    document.documentElement.setAttribute('data-theme', theme);
    const btn = document.getElementById('themeBtn');
    if (btn) btn.textContent = theme === 'dark' ? '\u2600' : '\u263E';
  }

  // --- Build the DOM ---
  function render() {
    // Compute viewBox bounds
    const allX = Object.values(stations).map(s => s.x);
    const allY = Object.values(stations).map(s => s.y);
    const padding = 120;
    const minX = Math.min(...allX) - padding;
    const minY = Math.min(...allY) - padding;
    const maxX = Math.max(...allX) + padding;
    const maxY = Math.max(...allY) + padding;
    const vbW = maxX - minX;
    const vbH = maxY - minY;

    const stationCount = Object.keys(stations).length;
    const firstLineColor = Object.values(lines)[0]?.color || '#003688';

    document.body.innerHTML = `
      <div class="frame">
        <header>
          <svg class="header-roundel" viewBox="0 0 36 36">
            <circle cx="18" cy="18" r="17" fill="${firstLineColor}" stroke="none"/>
            <rect x="1" y="12.5" width="34" height="11" rx="5.5" fill="${firstLineColor}" stroke="white" stroke-width="2"/>
            <text x="18" y="21" text-anchor="middle" fill="white" font-family="Inter, sans-serif" font-weight="700" font-size="8" letter-spacing="0.5">${project.name.substring(0, 2).toUpperCase()}</text>
          </svg>
          <div class="header-text">
            <span class="title">${project.name}</span>
            <span class="subtitle">${project.subtitle}</span>
          </div>
          <div class="search-wrap">
            <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="7" cy="7" r="5"/>
              <line x1="10.5" y1="10.5" x2="14" y2="14"/>
            </svg>
            <input type="text" id="searchInput" placeholder="Search stations..." autocomplete="off"/>
          </div>
          <div class="header-controls">
            <button class="icon-btn" id="themeBtn" title="Toggle theme">${theme === 'dark' ? '\u2600' : '\u263E'}</button>
            <button class="icon-btn" id="exportBtn" title="Export SVG">\u21E9</button>
          </div>
        </header>

        <div class="legend" id="legend">
          ${Object.entries(lines).map(([id, l]) =>
            `<div class="legend-item" data-line="${id}">
              <span class="legend-swatch" style="background:${l.color}"></span>
              <span>${l.label}</span>
            </div>`
          ).join('')}
        </div>

        <div class="controls">
          <button onclick="zoomIn()" title="Zoom in">+</button>
          <button onclick="resetView()" title="Reset view">\u25CB</button>
          <button onclick="zoomOut()" title="Zoom out">\u2212</button>
        </div>

        <span class="station-count">${stationCount} stations</span>

        <div class="map-wrap" id="mapWrap">
          <svg id="map" viewBox="${minX} ${minY} ${vbW} ${vbH}">
            <defs>
              <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="blur"/>
                <feMerge>
                  <feMergeNode in="blur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
              <filter id="pulse-glow" x="-100%" y="-100%" width="300%" height="300%">
                <feGaussianBlur stdDeviation="4" result="blur"/>
                <feMerge>
                  <feMergeNode in="blur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>

            <!-- Dot grid -->
            <pattern id="dotGrid" x="0" y="0" width="30" height="30" patternUnits="userSpaceOnUse">
              <circle cx="15" cy="15" r="0.8" class="dot-grid"/>
            </pattern>
            <rect x="${minX}" y="${minY}" width="${vbW}" height="${vbH}" fill="url(#dotGrid)"/>

            <g id="viewport">
              <!-- Paths -->
              <g id="pathsGroup">
                ${paths.map((p, i) => {
                  const d = generatePathD(p.stations);
                  const dashArray = p.type === 'branch' ? '8,6' : 'none';
                  return `<path class="map-line" data-line="${p.line}" data-path-idx="${i}"
                    style="stroke:${lines[p.line].color}; stroke-dasharray:${dashArray}"
                    d="${d}"/>`;
                }).join('\n')}
              </g>

              <!-- Pulse dots container (for path tracing animation) -->
              <g id="pulseGroup"></g>

              <!-- Stations -->
              <g id="stationsGroup">
                ${Object.entries(stations).map(([id, s]) => {
                  const line = lines[s.line];
                  const label = computeLabelPos(id, s);
                  const displayName = s.name.replace('.py', '').replace('.js', '').replace('.ts', '').replace('.tsx', '').replace('.go', '').replace('.rs', '');

                  if (s.type === 'terminal') {
                    // Capsule terminal
                    const w = 56, h = 28;
                    return `
                      <g class="station" data-id="${id}" tabindex="0" role="button" aria-label="${s.name}">
                        <rect class="terminal-rect" x="${s.x - w/2}" y="${s.y - h/2}"
                          width="${w}" height="${h}" fill="${line.color}" stroke="${line.color}" stroke-width="2"/>
                        <rect class="terminal-inner-rect" x="${s.x - w/2 + 4}" y="${s.y - h/2 + 4}"
                          width="${w - 8}" height="${h - 8}"/>
                        <text class="station-label" x="${label.lx}" y="${label.ly}"
                          text-anchor="${label.anchor}" style="font-size:10px; font-weight:700">${displayName}</text>
                      </g>`;
                  }

                  if (s.type === 'interchange') {
                    // Double-circle roundel
                    const outerR = 15;
                    const midR = 12;
                    const innerR = 8;
                    return `
                      <g class="station interchange" data-id="${id}" tabindex="0" role="button" aria-label="${s.name}">
                        <circle class="station-outer" cx="${s.x}" cy="${s.y}" r="${outerR}" fill="${line.color}" stroke="${line.color}" stroke-width="2"/>
                        <circle class="station-inner" cx="${s.x}" cy="${s.y}" r="${midR}" fill="var(--station-fill)" stroke="var(--station-fill)" stroke-width="0"/>
                        <circle cx="${s.x}" cy="${s.y}" r="${innerR}" fill="${line.color}" pointer-events="none"/>
                        <text class="station-label" x="${label.lx}" y="${label.ly}"
                          text-anchor="${label.anchor}">${displayName}</text>
                      </g>`;
                  }

                  // Regular: roundel (colored circle with white center)
                  const outerR = 11;
                  const innerR = 6;
                  return `
                    <g class="station" data-id="${id}" tabindex="0" role="button" aria-label="${s.name}">
                      <circle class="station-outer" cx="${s.x}" cy="${s.y}" r="${outerR}" fill="${line.color}" stroke="${line.color}" stroke-width="2"/>
                      <circle class="station-inner" cx="${s.x}" cy="${s.y}" r="${innerR}"/>
                      <text class="station-label" x="${label.lx}" y="${label.ly}"
                        text-anchor="${label.anchor}">${displayName}</text>
                    </g>`;
                }).join('\n')}
              </g>
            </g>
          </svg>
        </div>
      </div>

      <div class="tooltip" id="tooltip">
        <div class="tooltip-name" id="tooltipName"></div>
        <div class="tooltip-role" id="tooltipRole"></div>
      </div>

      <div class="overlay" id="overlay"></div>

      <div class="panel" id="panel">
        <button class="panel-close" id="panelClose">\u00D7</button>
        <div class="panel-head">
          <div class="panel-roundel" id="panelRoundel">
            <div class="panel-roundel-inner"></div>
          </div>
          <span class="panel-name" id="panelName"></span>
        </div>
        <div class="panel-path" id="panelPath"></div>
        <hr class="panel-divider"/>
        <div class="panel-section-title">What it does</div>
        <div class="panel-role" id="panelRole"></div>
        <div class="panel-section-title">Technical details</div>
        <div class="panel-details" id="panelDetails"></div>
        <hr class="panel-divider"/>
        <div class="panel-section-title">Connections</div>
        <div class="panel-conn" id="panelConn"></div>
      </div>

      <div class="export-toast" id="exportToast">SVG exported</div>
    `;

    applyTheme();
    setupInteractions();
  }

  // ============================================================================
  // INTERACTIONS
  // ============================================================================

  function setupInteractions() {
    const svg = document.getElementById('map');
    const vp = document.getElementById('viewport');
    const mapWrap = document.getElementById('mapWrap');
    const tooltip = document.getElementById('tooltip');

    // --- Pan / Zoom state ---
    let vx = 0, vy = 0, vk = 1;
    let isPanning = false, panStartX = 0, panStartY = 0, panStartVX = 0, panStartVY = 0;

    function applyTransform(animate) {
      if (animate) {
        vp.style.transition = 'transform 0.3s ease';
        setTimeout(() => vp.style.transition = '', 350);
      }
      vp.setAttribute('transform', `translate(${vx},${vy}) scale(${vk})`);
    }

    // Mouse pan
    mapWrap.addEventListener('mousedown', e => {
      if (e.target.closest('.station')) return;
      isPanning = true;
      panStartX = e.clientX;
      panStartY = e.clientY;
      panStartVX = vx;
      panStartVY = vy;
    });

    document.addEventListener('mousemove', e => {
      if (!isPanning) return;
      const rect = svg.getBoundingClientRect();
      const svgVB = svg.viewBox.baseVal;
      const scaleX = svgVB.width / rect.width;
      const scaleY = svgVB.height / rect.height;
      vx = panStartVX + (e.clientX - panStartX) * scaleX;
      vy = panStartVY + (e.clientY - panStartY) * scaleY;
      applyTransform(false);
    });

    document.addEventListener('mouseup', () => isPanning = false);

    // Wheel zoom
    mapWrap.addEventListener('wheel', e => {
      e.preventDefault();
      const rect = svg.getBoundingClientRect();
      const svgVB = svg.viewBox.baseVal;
      const mouseX = svgVB.x + (e.clientX - rect.left) / rect.width * svgVB.width;
      const mouseY = svgVB.y + (e.clientY - rect.top) / rect.height * svgVB.height;

      const oldK = vk;
      const factor = e.deltaY > 0 ? 0.92 : 1.08;
      vk = Math.max(0.3, Math.min(4, vk * factor));

      // Zoom toward mouse position
      vx = mouseX - (mouseX - vx) * (vk / oldK);
      vy = mouseY - (mouseY - vy) * (vk / oldK);

      applyTransform(false);
    }, { passive: false });

    // Touch pan/zoom
    let touches = [];
    let lastTouchDist = 0;

    mapWrap.addEventListener('touchstart', e => {
      touches = [...e.touches];
      if (touches.length === 2) {
        lastTouchDist = Math.hypot(
          touches[1].clientX - touches[0].clientX,
          touches[1].clientY - touches[0].clientY
        );
      } else if (touches.length === 1) {
        isPanning = true;
        panStartX = touches[0].clientX;
        panStartY = touches[0].clientY;
        panStartVX = vx;
        panStartVY = vy;
      }
    }, { passive: true });

    mapWrap.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 2) {
        const dist = Math.hypot(
          e.touches[1].clientX - e.touches[0].clientX,
          e.touches[1].clientY - e.touches[0].clientY
        );
        const factor = dist / lastTouchDist;
        vk = Math.max(0.3, Math.min(4, vk * factor));
        lastTouchDist = dist;
        applyTransform(false);
      } else if (isPanning && e.touches.length === 1) {
        const rect = svg.getBoundingClientRect();
        const svgVB = svg.viewBox.baseVal;
        const scaleX = svgVB.width / rect.width;
        const scaleY = svgVB.height / rect.height;
        vx = panStartVX + (e.touches[0].clientX - panStartX) * scaleX;
        vy = panStartVY + (e.touches[0].clientY - panStartY) * scaleY;
        applyTransform(false);
      }
    }, { passive: false });

    mapWrap.addEventListener('touchend', () => { isPanning = false; });

    // Zoom buttons
    window.zoomIn = () => { vk = Math.min(4, vk * 1.3); applyTransform(true); };
    window.zoomOut = () => { vk = Math.max(0.3, vk * 0.77); applyTransform(true); };
    window.resetView = () => { vx = 0; vy = 0; vk = 1; applyTransform(true); };

    // --- Tooltip ---
    const stationEls = document.querySelectorAll('.station');

    stationEls.forEach(el => {
      el.addEventListener('mouseenter', e => {
        if (document.getElementById('panel').classList.contains('on')) return;
        const id = el.dataset.id;
        const s = stations[id];
        if (!s) return;

        document.getElementById('tooltipName').textContent = s.name;
        document.getElementById('tooltipRole').textContent = s.role;
        tooltip.classList.add('show');
      });

      el.addEventListener('mousemove', e => {
        tooltip.style.left = (e.clientX + 14) + 'px';
        tooltip.style.top = (e.clientY - 10) + 'px';

        // Keep tooltip in viewport
        const rect = tooltip.getBoundingClientRect();
        if (rect.right > window.innerWidth - 10) {
          tooltip.style.left = (e.clientX - rect.width - 14) + 'px';
        }
        if (rect.bottom > window.innerHeight - 10) {
          tooltip.style.top = (e.clientY - rect.height - 10) + 'px';
        }
      });

      el.addEventListener('mouseleave', () => {
        tooltip.classList.remove('show');
      });
    });

    // --- Station click: path tracing ---
    stationEls.forEach(el => {
      el.addEventListener('click', e => {
        e.stopPropagation();
        const id = el.dataset.id;

        if (selectedStation === id) {
          // Second click: open detail panel
          openPanel(id);
          return;
        }

        // First click: highlight paths
        selectStation(id);
      });
    });

    // Click background to deselect
    mapWrap.addEventListener('click', e => {
      if (!e.target.closest('.station')) {
        clearSelection();
      }
    });

    // --- Path tracing ---
    function selectStation(id) {
      selectedStation = id;
      const { upstream, downstream } = findConnected(id);
      const connected = new Set([id, ...upstream, ...downstream]);

      // Dim unrelated stations
      stationEls.forEach(el => {
        const sid = el.dataset.id;
        if (connected.has(sid)) {
          el.classList.remove('dimmed');
          el.classList.add('highlighted');
        } else {
          el.classList.add('dimmed');
          el.classList.remove('highlighted');
        }
      });

      // Dim unrelated paths
      document.querySelectorAll('.map-line').forEach(pathEl => {
        const idx = parseInt(pathEl.dataset.pathIdx);
        const pathDef = paths[idx];
        if (pathConnectsTo(pathDef, connected)) {
          pathEl.classList.remove('dimmed');
          pathEl.classList.add('highlighted');
        } else {
          pathEl.classList.add('dimmed');
          pathEl.classList.remove('highlighted');
        }
      });

      // Add pulse dots on connected paths
      addPulseDots(id, connected);
    }

    function clearSelection() {
      selectedStation = null;
      stationEls.forEach(el => {
        el.classList.remove('dimmed', 'highlighted');
      });
      document.querySelectorAll('.map-line').forEach(p => {
        p.classList.remove('dimmed', 'highlighted');
      });
      removePulseDots();
    }

    function addPulseDots(stationId, connected) {
      removePulseDots();
      const pulseGroup = document.getElementById('pulseGroup');

      paths.forEach((p, i) => {
        if (!pathConnectsTo(p, connected)) return;
        if (p.stations.length < 2) return;

        const pathEl = document.querySelector(`.map-line[data-path-idx="${i}"]`);
        if (!pathEl) return;

        const d = pathEl.getAttribute('d');
        const lineColor = lines[p.line].color;

        // Create a hidden path for offset-path
        const motionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        motionPath.setAttribute('d', d);
        motionPath.setAttribute('id', `motion-${i}`);
        motionPath.setAttribute('fill', 'none');
        motionPath.setAttribute('stroke', 'none');
        pulseGroup.appendChild(motionPath);

        // Create animated dot
        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('r', '4');
        dot.setAttribute('fill', 'white');
        dot.setAttribute('opacity', '0.9');
        dot.classList.add('pulse-anim-dot');

        // Animate along path using SMIL
        const animMotion = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
        animMotion.setAttribute('dur', `${1.5 + Math.random() * 1.5}s`);
        animMotion.setAttribute('repeatCount', 'indefinite');
        const mpath = document.createElementNS('http://www.w3.org/2000/svg', 'mpath');
        mpath.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#motion-${i}`);
        animMotion.appendChild(mpath);
        dot.appendChild(animMotion);

        pulseGroup.appendChild(dot);
      });
    }

    function removePulseDots() {
      const pulseGroup = document.getElementById('pulseGroup');
      if (pulseGroup) pulseGroup.innerHTML = '';
    }

    // --- Detail panel ---
    function openPanel(id) {
      const s = stations[id];
      if (!s) return;
      const line = lines[s.line];

      document.getElementById('panelRoundel').style.background = line.color;
      document.getElementById('panelName').innerHTML = s.name +
        (s.badge ? `<span class="panel-badge">${s.badge}</span>` : '');
      document.getElementById('panelPath').textContent = s.path;
      document.getElementById('panelRole').textContent = s.role;
      document.getElementById('panelDetails').textContent = s.details;

      // Connections
      let connHtml = '';
      if (s.feeds && s.feeds.length) {
        s.feeds.forEach(fid => {
          const fs = stations[fid];
          if (fs) {
            connHtml += `<div class="panel-conn-row">
              <span class="panel-conn-arrow downstream">\u2192</span>
              <span class="panel-conn-name">${fs.name}</span>
            </div>`;
          }
        });
      }
      if (s.fed_by && s.fed_by.length) {
        s.fed_by.forEach(fid => {
          const fs = stations[fid];
          if (fs) {
            connHtml += `<div class="panel-conn-row">
              <span class="panel-conn-arrow upstream">\u2190</span>
              <span class="panel-conn-name">${fs.name}</span>
            </div>`;
          }
        });
      }
      if (!connHtml) connHtml = '<div style="color:var(--fg-dim); font-size:12px">No direct connections</div>';
      document.getElementById('panelConn').innerHTML = connHtml;

      document.getElementById('overlay').classList.add('on');
      document.getElementById('panel').classList.add('on');
    }

    window.openPanel = openPanel;

    // Close panel
    document.getElementById('overlay').addEventListener('click', closePanel);
    document.getElementById('panelClose').addEventListener('click', closePanel);

    function closePanel() {
      document.getElementById('overlay').classList.remove('on');
      document.getElementById('panel').classList.remove('on');
    }

    // --- Search ---
    const searchInput = document.getElementById('searchInput');
    searchInput.addEventListener('input', e => {
      searchQuery = e.target.value.toLowerCase().trim();
      applySearch();
    });

    function applySearch() {
      if (!searchQuery) {
        stationEls.forEach(el => el.classList.remove('dimmed'));
        document.querySelectorAll('.map-line').forEach(p => p.classList.remove('dimmed'));
        return;
      }

      const matching = new Set();
      Object.entries(stations).forEach(([id, s]) => {
        const haystack = `${s.name} ${s.role} ${s.path} ${s.details}`.toLowerCase();
        if (haystack.includes(searchQuery)) {
          matching.add(id);
        }
      });

      stationEls.forEach(el => {
        if (matching.has(el.dataset.id)) {
          el.classList.remove('dimmed');
          el.classList.add('highlighted');
        } else {
          el.classList.add('dimmed');
          el.classList.remove('highlighted');
        }
      });

      // Dim paths not connected to any matching station
      document.querySelectorAll('.map-line').forEach(pathEl => {
        const idx = parseInt(pathEl.dataset.pathIdx);
        const pathDef = paths[idx];
        if (pathConnectsTo(pathDef, matching)) {
          pathEl.classList.remove('dimmed');
        } else {
          pathEl.classList.add('dimmed');
        }
      });
    }

    // --- Legend filter ---
    document.querySelectorAll('.legend-item').forEach(el => {
      el.addEventListener('click', () => {
        const lineId = el.dataset.line;
        if (hiddenLines.has(lineId)) {
          hiddenLines.delete(lineId);
          el.classList.remove('dimmed');
        } else {
          hiddenLines.add(lineId);
          el.classList.add('dimmed');
        }
        applyLegendFilter();
      });
    });

    function applyLegendFilter() {
      // Hide/show paths
      document.querySelectorAll('.map-line').forEach(pathEl => {
        const lineId = pathEl.dataset.line;
        pathEl.style.display = hiddenLines.has(lineId) ? 'none' : '';
      });

      // Hide/show stations
      stationEls.forEach(el => {
        const id = el.dataset.id;
        const s = stations[id];
        if (!s) return;
        const sLines = stationLines(id);
        // Hide if ALL of this station's lines are hidden
        const allHidden = [...sLines].every(l => hiddenLines.has(l));
        el.style.display = allHidden ? 'none' : '';
      });
    }

    // --- Theme toggle ---
    document.getElementById('themeBtn').addEventListener('click', () => {
      theme = theme === 'dark' ? 'light' : 'dark';
      applyTheme();
    });

    // --- SVG export ---
    document.getElementById('exportBtn').addEventListener('click', () => {
      const svgEl = document.getElementById('map');
      const clone = svgEl.cloneNode(true);

      // Inline computed styles
      const styleSheet = document.querySelector('style').textContent;
      const styleEl = document.createElementNS('http://www.w3.org/2000/svg', 'style');
      styleEl.textContent = styleSheet;
      clone.prepend(styleEl);

      clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      const svgData = new XMLSerializer().serializeToString(clone);
      const blob = new Blob([svgData], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${project.name.toLowerCase().replace(/\s+/g, '-')}-subway-map.svg`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      // Toast
      const toast = document.getElementById('exportToast');
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    });

    // --- Keyboard navigation ---
    const stationIds = Object.keys(stations);
    let focusIdx = -1;

    document.addEventListener('keydown', e => {
      // Escape closes panel or clears selection
      if (e.key === 'Escape') {
        if (document.getElementById('panel').classList.contains('on')) {
          closePanel();
        } else {
          clearSelection();
          searchInput.blur();
        }
        return;
      }

      // Tab cycles stations (when not in search)
      if (e.key === 'Tab' && document.activeElement !== searchInput) {
        e.preventDefault();
        focusIdx = (focusIdx + (e.shiftKey ? -1 : 1) + stationIds.length) % stationIds.length;
        const el = document.querySelector(`.station[data-id="${stationIds[focusIdx]}"]`);
        if (el) el.focus();
        return;
      }

      // Enter on focused station
      if (e.key === 'Enter' && document.activeElement?.classList.contains('station')) {
        const id = document.activeElement.dataset.id;
        if (selectedStation === id) {
          openPanel(id);
        } else {
          selectStation(id);
        }
        return;
      }

      // / focuses search
      if (e.key === '/' && document.activeElement !== searchInput) {
        e.preventDefault();
        searchInput.focus();
      }
    });
  }

  // --- Initialize ---
  render();
});
</script>

</body>
</html>
